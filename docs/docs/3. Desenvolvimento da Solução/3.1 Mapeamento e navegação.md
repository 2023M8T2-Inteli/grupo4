# Mapeamento e navegação

Esta seção da documentação concentra-se no processo essencial que permite a um robô mover-se autonomamente em um ambiente desconhecido. Primeiramente, abordaremos como o robô cria um mapa do ambiente ao seu redor, identificando obstáculos e rotas possíveis. Em seguida, discutiremos a importância de uma interface de comunicação eficaz que permite aos usuários especificar pontos para onde desejam que o robô se mova. Essa interface organiza esses pontos em uma sequência lógica e os transmite ao robô na ordem correta. Este fluxo integrado de mapeamento e comunicação é vital para a autonomia do robô. Abaixo, forneceremos detalhes mais aprofundados sobre cada etapa desse processo, explicando como cada componente contribui para a operação autônoma eficaz do robô.

## Tecnologias

A integração do ROS 2 (Robot Operating System 2), NAV2 (Navigation Stack 2) e TurtleBot3 desempenha um papel central em nossa arquitetura de projeto para sistemas de AMR (Autonomous Mobile Robots), especialmente relevantes para a implementação de navegação autônoma em ambientes industriais. O ROS 2, como sistema operacional para robôs, oferece uma base robusta para o desenvolvimento, enquanto o NAV2, parte integrante do ecossistema ROS 2, fornece recursos avançados de navegação, incluindo algoritmos de mapeamento, localização e planejamento de trajetória.

Nesse contexto, o TurtleBot3, modular e flexível, se conecta ao ROS 2 e NAV2, proporcionando uma plataforma pronta para aplicação prática. Este conjunto de tecnologias possibilita a criação de soluções autônomas e eficientes para robôs de entrega de ferramentas em ambientes industriais. O TurtleBot3, ao se beneficiar da navegação autônoma proporcionada pelo NAV2 e da infraestrutura do ROS 2, pode ser programado para navegar de forma inteligente, otimizando rotas, evitando obstáculos e realizando entregas autônomas.

Em nosso projeto, essa sucessão de tecnologias cria uma base sólida para a automação e eficiência nas operações logísticas internas. A interação entre ROS 2, NAV2 e TurtleBot3 visa impulsionar a navegação autônoma de robôs de entrega de ferramentas, representando um avanço significativo na aplicação de tecnologias de ponta para melhorar as operações industriais. Essa documentação destaca a sinergia entre essas tecnologias, evidenciando como elas se combinam para criar uma solução integrada e eficaz para nossos objetivos de projeto.

### Tópicos e nós 

No contexto do ROS (Robot Operating System), os conceitos fundamentais de nós e tópicos desempenham papéis cruciais na comunicação e coordenação entre diferentes partes de um sistema robótico. Um "nó" no ROS é uma unidade computacional autônoma que executa uma tarefa específica, seja controlar um sensor, processar dados ou realizar ações físicas. Cada nó é um processo independente que se comunica com outros nós para trocar informações.

Os "tópicos" são canais de comunicação que facilitam a troca de dados entre os nós. Eles representam fluxos de informações unidirecionais, onde um nó pode publicar dados em um tópico e outros nós podem se inscrever para receber esses dados. Essa arquitetura baseada em tópicos permite uma comunicação eficiente e desacoplada entre os nós, contribuindo para a modularidade e flexibilidade do sistema.

Em resumo, no ROS, os "nós" são entidades autônomas que executam tarefas específicas, enquanto os "tópicos" são canais de comunicação que possibilitam a troca de dados entre esses nós. Essa abordagem facilita a construção de sistemas robóticos complexos, onde diferentes componentes podem operar de maneira independente e colaborativa por meio de uma estrutura de comunicação flexível e eficaz.

## Módulos

ESte projeto é dividido em dois workspaces localizados na pasta src/bridge. O primeiro workspace é dedicado ao mapeamento, enquanto o segundo lida com a navegação.

### Mapeamento (mapping_launch)

O workspace de mapeamento contém um launcher em C++ que inicia os pacotes de teleop (controle manual) e Cartographer (mapeamento). Além disso, um script em bash está presente para salvar automaticamente o mapa gerado como um arquivo YAML e uma imagem quando o comando Ctrl+C é pressionado no terminal.

#### Execução

Para executar o mapeamento, utilize os seguintes comandos na pasta raiz do workspace:

```bash

chmod +x mapping_zsh.sh
./mapping_zsh.sh

```

No terminal extra que será aberto, utilize o teclado para movimentar o robô. Na aba de navegação com Rviz, observe a formação do mapa. Quando ele estiver bem definido, pressione Ctrl-C no terminal inicial para salvar o mapa. Ele será salvo na pasta do workspace com o nome "map.yaml" e "map.pgm".


### Navegação (nav_workspace)
O workspace de navegação contém um pacote com um script em bash que inicia o Rviz com um arquivo de mapa fornecido como argumento. Além disso, há cinco nós: um para abrir um terminal de chatbot, um para abrir um terminal de entrada de coordenadas, um nó para inicializar a pose do robô, e um nó para gerenciar a fila de pontos. O quinto nó, chamado Vallet, utiliza a API do Simple Commander para comunicação programática com o Nav2. As conexões entre esses tópicos podem ser visualizadas na imagem abaixo. Note que o nó de inicialização de pose não é visível porque ele se encerra assim que a pose é publicada, diferentemente dos outros, que permanecem ativos até o final da interação do usuário.

![Alt text](../../static/img/topic_graph.png)


#### Execução

Para executar a navegação, utilize os seguintes comandos na pasta raiz do workspace:

```bash

colcon build
source install/setup.bash
bash run.sh <nome-do-mapa>.yaml

```

Tanto através do chatbot quanto do terminal de coordenadas, é possível enviar pontos para o robô. Esses pontos são publicados no tópico chatbot_msgs como mensagens do tipo Pose. O nó de fila se inscreve nesse tópico, enfileira os pontos e aguarda o status do nó Vallet.

Quando o nó Vallet está disponível, a fila publica o próximo ponto no tópico poses. O nó Vallet escuta esse tópico, envia uma ação de goToPose quando disponível e aguarda uma nova pose. Após a conclusão, o nó Vallet publica "Busy" no tópico status, indicando que está ocupado, e posteriormente, "Free" ao finalizar.

## Demo

<video controls>
  <source src="../../static/video/demo.mp4"/>
</video>


# Transição da Simulação para Robô Real em Mapeamento e Navegação

A transição do ambiente de simulação para a execução em um robô real requer ajustes minuciosos nas configurações de lançamento e nos parâmetros de código para garantir a precisão da navegação autônoma. Este documento descreve as mudanças específicas implementadas para adaptar o mapeamento e a navegação do Turtlebot3 no ambiente Gazebo para o seu equivalente no mundo real.

### Configurações de Lançamento para Mapeamento

Para a simulação no Gazebo, o lançamento é realizado através do arquivo `mapping_gazebo.launch.py`, que configura o ambiente virtual e os parâmetros de simulação. A seguir, um trecho do arquivo de simulação:

```python
# mapping_gazebo.launch.py
gazebo_dir = get_package_share_directory('turtlebot3_gazebo')
...
PythonLaunchDescriptionSource(gazebo_dir + '/launch/turtlebot3_world.launch.py')
```

Comparativamente, para o Turtlebot3 real, o arquivo `mapping_turtlebot3.launch.py` faz referência ao pacote `turtlebot3_cartographer`, que se liga aos sensores físicos para o mapeamento preciso do ambiente. Aqui está um trecho correspondente:

```python
# mapping_turtlebot3.launch.py
cartographer_dir = get_package_share_directory('turtlebot3_cartographer')
...
PythonLaunchDescriptionSource(cartographer_dir + '/launch/cartographer.launch.py')
```

A diferença chave está no uso do pacote `turtlebot3_cartographer` no lugar de `turtlebot3_gazebo`, refletindo a necessidade de interagir com hardware real ao invés de uma simulação.

### Configurações de Lançamento para Navegação

As diferenças entre a navegação na simulação e no robô real são evidentes nos arquivos de lançamento específicos. No Gazebo, o arquivo `navigation_gazebo.launch.py` carrega o mapa da simulação e configurações pré-estabelecidas para o Rviz:

```python
# navigation_gazebo.launch.py
rviz_dir = get_package_share_directory('turtlebot3_navigation2')
map_file_path = os.path.join(os.getcwd(), 'map_gazebo.yaml')
...
```

Em contraste, o `navigation_turtlebot3.launch.py` carrega o mapa do Turtlebot3 real e ajusta as configurações de navegação para se adequar às condições físicas do ambiente:

```python
# navigation_turtlebot3.launch.py
rviz_dir = get_package_share_directory('turtlebot3_navigation2')
map_file_path = os.path.join(os.getcwd(), 'map_turtlebot3.yaml')
...
```

### Considerações sobre a Interface de Comunicação

O robô simulado pode se basear em interfaces de alto nível e em suposições simplificadas sobre o ambiente, enquanto o robô real necessita de uma comunicação mais complexa e detalhada para lidar com as incertezas e as dinâmicas do mundo real. Portanto, é essencial que a transição inclua uma revisão da interface de comunicação para garantir que as instruções de navegação sejam precisas e adaptáveis às condições em tempo real.

As seguintes linhas de código demonstram uma transição na configuração do RViz, refletindo a mudança do ambiente virtual para o físico:

```python
# navigation_gazebo.launch.py (Gazebo simulation)
...
rviz_config_file = os.path.join(rviz_dir, 'rviz', 'tb3_gazebo.rviz')
...

# navigation_turtlebot3.launch.py (Real Turtlebot3)
...
rviz_config_file = os.path.join(rviz_dir, 'rviz', 'tb3_real.rviz')
...
```

Ajustes similares são feitos para os nós de localização e mapeamento, onde parâmetros como a taxa de atualização do mapa, o modelo de sensor e os filtros de processamento de dados são calibrados para as condições específicas do robô e de seus sensores.

### Ajustes Finais e Testes

Antes de finalizar a transição, é crucial realizar uma série de testes para assegurar que o robô se comporta conforme o esperado no ambiente real. Testes de integração e de sistema validam as funções de mapeamento, localização e planejamento de rotas, enquanto a análise de desempenho ajuda a ajustar os parâmetros de navegação para otimizar a eficiência e a segurança.

A documentação e os fragmentos de código fornecidos devem ser usados como um guia para desenvolvedores ao adaptar projetos de robótica de simulações para aplicações do mundo real, assegurando que as transições sejam suaves e que o robô mantenha sua operacionalidade em novos ambientes.

### Conclusão

Em suma, a transição do simulado para o real envolve modificações na interface de usuário e no processamento de dados sensoriais. Por exemplo, enquanto a simulação pode utilizar parâmetros generalizados para detecção de obstáculos, o robô real deve ajustar esses parâmetros para refletir as características específicas de seus sensores e do ambiente operacional.

A conversão bem-sucedida de um sistema de simulação para aplicação em um robô autônomo real é crítica para o avanço da robótica prática. As alterações apresentadas garantem a integração harmoniosa entre o software de simulação e as as capacidades do robô físico. Este processo de adaptação não apenas reafirma a funcionalidade e a confiabilidade do sistema em ambientes reais, mas também destaca a importância da escalabilidade e flexibilidade do design do software.