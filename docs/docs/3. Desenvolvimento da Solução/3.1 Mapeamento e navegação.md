# Mapeamento e navegação

Esta seção da documentação concentra-se no processo essencial que permite a um robô mover-se autonomamente em um ambiente desconhecido. Primeiramente, abordaremos como o robô cria um mapa do ambiente ao seu redor, identificando obstáculos e rotas possíveis. Em seguida, discutiremos a importância de uma interface de comunicação eficaz que permite aos usuários especificar pontos para onde desejam que o robô se mova. Essa interface organiza esses pontos em uma sequência lógica e os transmite ao robô na ordem correta. Este fluxo integrado de mapeamento e comunicação é vital para a autonomia do robô. Abaixo, forneceremos detalhes mais aprofundados sobre cada etapa desse processo, explicando como cada componente contribui para a operação autônoma eficaz do robô.

## Tecnologias

A integração do ROS 2 (Robot Operating System 2), NAV2 (Navigation Stack 2) e TurtleBot3 desempenha um papel central em nossa arquitetura de projeto para sistemas de AMR (Autonomous Mobile Robots), especialmente relevantes para a implementação de navegação autônoma em ambientes industriais. O ROS 2, como sistema operacional para robôs, oferece uma base robusta para o desenvolvimento, enquanto o NAV2, parte integrante do ecossistema ROS 2, fornece recursos avançados de navegação, incluindo algoritmos de mapeamento, localização e planejamento de trajetória.

Nesse contexto, o TurtleBot3, modular e flexível, se conecta ao ROS 2 e NAV2, proporcionando uma plataforma pronta para aplicação prática. Este conjunto de tecnologias possibilita a criação de soluções autônomas e eficientes para robôs de entrega de ferramentas em ambientes industriais. O TurtleBot3, ao se beneficiar da navegação autônoma proporcionada pelo NAV2 e da infraestrutura do ROS 2, pode ser programado para navegar de forma inteligente, otimizando rotas, evitando obstáculos e realizando entregas autônomas.

Em nosso projeto, essa sucessão de tecnologias cria uma base sólida para a automação e eficiência nas operações logísticas internas. A interação entre ROS 2, NAV2 e TurtleBot3 visa impulsionar a navegação autônoma de robôs de entrega de ferramentas, representando um avanço significativo na aplicação de tecnologias de ponta para melhorar as operações industriais. Essa documentação destaca a sinergia entre essas tecnologias, evidenciando como elas se combinam para criar uma solução integrada e eficaz para nossos objetivos de projeto.

### Tópicos e nós 

No contexto do ROS (Robot Operating System), os conceitos fundamentais de nós e tópicos desempenham papéis cruciais na comunicação e coordenação entre diferentes partes de um sistema robótico. Um "nó" no ROS é uma unidade computacional autônoma que executa uma tarefa específica, seja controlar um sensor, processar dados ou realizar ações físicas. Cada nó é um processo independente que se comunica com outros nós para trocar informações.

Os "tópicos" são canais de comunicação que facilitam a troca de dados entre os nós. Eles representam fluxos de informações unidirecionais, onde um nó pode publicar dados em um tópico e outros nós podem se inscrever para receber esses dados. Essa arquitetura baseada em tópicos permite uma comunicação eficiente e desacoplada entre os nós, contribuindo para a modularidade e flexibilidade do sistema.

Em resumo, no ROS, os "nós" são entidades autônomas que executam tarefas específicas, enquanto os "tópicos" são canais de comunicação que possibilitam a troca de dados entre esses nós. Essa abordagem facilita a construção de sistemas robóticos complexos, onde diferentes componentes podem operar de maneira independente e colaborativa por meio de uma estrutura de comunicação flexível e eficaz.

## Módulos

ESte projeto é dividido em dois workspaces localizados na pasta src/bridge. O primeiro workspace é dedicado ao mapeamento, enquanto o segundo lida com a navegação.

### Mapeamento (mapping_launch)

O workspace de mapeamento contém um launcher em C++ que inicia os pacotes de teleop (controle manual) e Cartographer (mapeamento). Além disso, um script em bash está presente para salvar automaticamente o mapa gerado como um arquivo YAML e uma imagem quando o comando Ctrl+C é pressionado no terminal.

#### Execução

Para executar o mapeamento, utilize os seguintes comandos na pasta raiz do workspace:

```bash

chmod +x mapping_zsh.sh
./mapping_zsh.sh

```

No terminal extra que será aberto, utilize o teclado para movimentar o robô. Na aba de navegação com Rviz, observe a formação do mapa. Quando ele estiver bem definido, pressione Ctrl-C no terminal inicial para salvar o mapa. Ele será salvo na pasta do workspace com o nome "map.yaml" e "map.pgm".


### Navegação (nav_workspace)
O workspace de navegação contém um pacote com um script em bash que inicia o Rviz com um arquivo de mapa fornecido como argumento. Além disso, há cinco nós: um para abrir um terminal de chatbot, um para abrir um terminal de entrada de coordenadas, um nó para inicializar a pose do robô, e um nó para gerenciar a fila de pontos. O quinto nó, chamado Vallet, utiliza a API do Simple Commander para comunicação programática com o Nav2. As conexões entre esses tópicos podem ser visualizadas na imagem abaixo. Note que o nó de inicialização de pose não é visível porque ele se encerra assim que a pose é publicada, diferentemente dos outros, que permanecem ativos até o final da interação do usuário.

![Alt text](../../static/img/topic_graph.png)


#### Execução

Para executar a navegação, utilize os seguintes comandos na pasta raiz do workspace:

```bash

colcon build
source install/setup.bash
bash run.sh <nome-do-mapa>.yaml

```

Tanto através do chatbot quanto do terminal de coordenadas, é possível enviar pontos para o robô. Esses pontos são publicados no tópico chatbot_msgs como mensagens do tipo Pose. O nó de fila se inscreve nesse tópico, enfileira os pontos e aguarda o status do nó Vallet.

Quando o nó Vallet está disponível, a fila publica o próximo ponto no tópico poses. O nó Vallet escuta esse tópico, envia uma ação de goToPose quando disponível e aguarda uma nova pose. Após a conclusão, o nó Vallet publica "Busy" no tópico status, indicando que está ocupado, e posteriormente, "Free" ao finalizar.

## Demo

<video controls>
  <source src="../../static/video/demo.mp4"/>
</video>