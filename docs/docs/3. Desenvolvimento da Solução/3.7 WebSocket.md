# Integração de WhatsApp e Chatbot com ROS2 e Turtlebot3 via WebSocket

## Introdução
Focamos no desenvolvimento e integração de uma solução combinando chatbot do WhatsApp, API do ChatGPT/OpenAI e robótica com ROS2 e Turtlebot3, para dar andamento a nossa solução e concomitantemente otimizar os processos logísticos na fábrica da Ambev em Guarulhos.

#### Detalhes Técnicos com Exemplos de Código e Comentários

1. **Integração com WhatsApp e Chatbot (`openai.ts`):**
   - Script TypeScript para integração da API do ChatGPT/OpenAI com WhatsApp.
   - Código chave com comentários:
     ```typescript
     // Importando APIs necessárias
     import { ChatGPTAPI } from "chatgpt";
     import { Configuration, OpenAIApi } from "openai";

     // Rota do webhook para processamento de mensagens do WhatsApp
     app.post('/webhook', (req, res) => {
       const userMessage = req.body.message;  // Capturando mensagem do usuário
       const chatbotResponse = ChatGPTAPI.processMessage(userMessage); // Processando mensagem
       sendMessageToUser(chatbotResponse); // Enviando resposta para o usuário
     });

     // Configuração da conexão WebSocket
     import { io } from "socket.io-client";
     export function initOpenAI() {
         chatgpt = new ChatGPTAPI({...}); // Inicializando ChatGPTAPI
         openai = new OpenAIApi({...}); // Inicializando OpenAIApi
     }
     ```

2. **Gerenciamento de Dados e Comunicação (`streamer.py`):**
   - `streamer.py` para gerenciamento da transmissão de dados.
   - Código chave com comentários:
     ```python
     # Classe Streamer para gerenciamento de WebSocket e ROS2
     class Streamer:
         def __init__(self, node: Node, client: Any, socket_event: str):
             self.node = node  # Nó ROS
             ...

         # Método para emitir eventos no WebSocket
         def emit_event(self, msg: Any) -> None:
             try:
                 self.sio.emit(self.socket_event, msg)  # Emitindo mensagem via WebSocket
             except Exception as e:
                 self.node.get_logger().error(f'Failed to emit: {e}')  # Log de erro
     ```

3. **Controle e Navegação do Robô (`vallet.py`):**
   - `vallet.py` gerencia o controle do Turtlebot3 através do ROS2.
   - Código chave com comentários:
     ```python
     # Importações ROS2 para controle e navegação do robô
     from geometry_msgs.msg import Pose, Point, Quaternion
     from nav2_simple_commander.robot_navigator import BasicNavigator

     # Classe para controle do navegador do robô
     class NavigatorController(Node):
         ...
         # Método para publicar o status do robô
         def publish_status(self, status):
             msg = String()
             msg.data = status
             self.robot_status.publish(msg)  # Publicando status do robô

         # Método para executar comandos de navegação
         def execute_command(self, command):
             if command['action'] == 'move':
                 # Movendo o robô para uma pose específica
                 self.navigator.go_to_pose(self.create_pose(command['x'], command['y'], command['theta']))
             elif command['action'] == 'stop':
                 # Cancelando a navegação
                 self.navigator.cancel_navigation()
     ```

#### Processo de Integração
- Implementamos uma comunicação robusta entre o chatbot no WhatsApp, o servidor backend (TypeScript e Python), e o controle do Turtlebot3 via ROS2.
- Os comandos dos usuários são processados pela API do ChatGPT/OpenAI, transmitidos via WebSocket pelo `streamer.py`, e então encaminhados ao `vallet.py` para execução no Turtlebot3.

#### Teste e Validação

Durante a fase de teste e validação, conduzimos uma série de experimentos para garantir a eficácia e a confiabilidade da integração entre o chatbot do WhatsApp, a API do ChatGPT/OpenAI, e o sistema robótico ROS2 com Turtlebot3. Os testes foram estruturados para avaliar vários aspectos do sistema, incluindo a precisão da interpretação dos comandos do chatbot, a eficiência da comunicação via WebSocket, e a precisão e segurança na navegação do robô.

1. **Teste do Chatbot**: Validamos a capacidade do chatbot de entender e responder com precisão às solicitações dos usuários. Isso incluiu testes de diálogo em situações variadas para assegurar a robustez do processamento de linguagem natural.

2. **Teste de Comunicação WebSocket**: Verificamos a estabilidade e a rapidez da comunicação entre o backend do sistema e o Turtlebot3. Os comandos foram transmitidos sem interrupções e em tempo real, assegurando uma operação fluida e contínua.

3. **Teste de Navegação do Robô**: O Turtlebot3 foi submetido a vários cenários de navegação para garantir que ele se movimentasse e executasse tarefas conforme as instruções recebidas. Observamos a precisão na execução de comandos, a habilidade de evitar obstáculos e a eficiência no cumprimento das tarefas.

Os resultados dos testes foram satisfatórios, demonstrando que o sistema integrado é capaz de operar de maneira eficiente e confiável. A documentação detalhada desses testes, juntamente com um vídeo gravado das sessões de teste, fornece uma visão clara da funcionalidade e eficácia do sistema. Esta fase de teste e validação é crucial para assegurar que nosso sistema não só atenda às expectativas teóricas, mas também funcione de maneira eficiente e segura no ambiente real da fábrica. O vídeo gravado das sessões de teste servirá como uma demonstração prática dos resultados obtidos e da operação do sistema no contexto real.

<video width="560" height="315" autoplay>
  <source src="docs\static\video\teste_sprint3.mp4" type="video/mp4">
  Seu navegador não suporta vídeos.
</video>


#### Conclusão
A integração entre o chatbot do WhatsApp e o sistema robótico ROS2 e Turtlebot3 representa um avanço significativo na automação e eficiência da logística na fábrica da Ambev, objetivo de nosso projeto. Esta inovação melhora a produtividade e oferece uma interface de usuário intuitiva e eficaz. Os códigos comentados fornecem uma visão clara da lógica e funcionamento interno do projeto a os interessados, destacando a complexidade e eficácia da solução desenvolvida.
